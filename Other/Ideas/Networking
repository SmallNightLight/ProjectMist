2Rollback & Prediction


Only send input, the frame and a hash incooperating the input, frame and game state
When receiving the packet, the hash is evaluated to check if it matches the data.


int NetworkingFPS = 15 FPS (66.6ms) (~4 rendering frames)
rate of sending packets

int PhysicsFPS = 30 FPS (33.33ms)
the physics in the game are simulated every 

int RenderingFPS = variable
the rendering can be done at any frame rate, and interpolates between the physics frames. Allows sync. The physics are prioritized, so when the hardware cant keep up with the Physics, the Rendering FPS is decreased.
The rendering runs on a different thread

int RollbackFramesCount = 15 (500ms)

Related to the PhysicsFPS. 


Save the latest game states for the last (RollbackFramesCount) frames.


Simulation Thread:
1) Get Input
2) Generate Hash from input and previous game state
3) Generate packet with the frame (number, from last game state), input and hash
4) If (networking frame), send the packet to other clients, including recent packets
5) Check and get the received packets
6) Calculate next physics step using the most recent packet frame every client. Rollback to the frame with the  


Every game state / frame keeps track of which clients it knows the input from and which client is predicted. When no client needed to be predicted this Game state is sealed and is the minimum next rollback target




When connecting to a game that is already active the new player first requests the gamedata to download. In the meantime the other players are already sending input to he new player even if he is still downloading. When the download is somplete he will first use the received input to catch up as fast as possible to the current game state.

When sending the input you also send the input of the last
RollbackFramesCount.


Issues
Lag spike: 
Player 1 - 2: 30ms
Player 2 - 3: 50ms
Player 3 - 1: 3s

Player 3 and 1 both realize there is a bad connection between them and send to each other to snap back to original position
So maybe a server is needed on one clients, who deals 

Idea:
Priority list of the clients: based on the connection speed (better connection: higher priority)
with higher priority the player will

Every client has their own priority list of other clients. In case 
Is also has a priority list of itselfs on other clients

So there is a 2s delay between two clients, they both are at the bottom priority list and 

Priority list needs to be same for every client

so when there is a lag spike every client who detects it compares the priority and if it is bigger then the other client, it sends out the complete game state back. The client now might now expects from every higher client with slow connection a game data package. so from some clients it receives the input, which are immediatly applied and from other ot first does not receive anything for 2s. In this case if the last unknown frame > max rollback frames, the player will apply this time the previous inputs of itself to the screen. The other clients that have detected the slow 

Every time a package is send the client also send the connection speeds that it has with the other clients (in frames) (1 byte), so all clients know when they dont receive packages if they, or the other client is the reason for this

Send: 
- the last perfect frame the frame that it knwos it correct with all input received)
- the last frame where it received the input of every client

sum up the framesof every connection that a clinet has and compare the value with its own average connection. Since it took time add the connection speed in frames it has with the other client

this comparison might still be off

so if it doesnt receive the needed input in time at th moment it needs to know the input in order to progress decide at this moment in time if it stops otself or if it stops the other

perfect (most likely): one stopped itself, the other stopped the other
bad (not likely): both stopped themselves. They both re

2 frames rollback (66ms) : no penalty (only input predicttion)
3 - 7 frames rollback (100ms - 233ms) : delay package to other client
8 - 60 frames rollback (266ms - 2000ms) : if client is the reason: only do rollback when all input is known, while waiting for input: keep previous input and  input when client is the cause and then just stop rendering until client received all input and can . only calculate 


Constant input prediction


Solution; Allow for more rollback time, (lik up to 2s, but stil make a limit of where it should stop waiting for input and progress without the other clinet that has bad connection





Optimizing
Combining with partition trees - when calculating a completely new frame, also save the collision response data and send it to the previous game state. When resimulating a frame, it checks which objects have been directly affected by the new input. Then get the cells where these objects are located and just apply the veloicity and angular velocity without additional calculations.
Interpolation
A rendering world - gets the necesarry components from the world manager

It needs: the current layer 



for animation:
it recalculates the animation time step every step.


Simulate(2)
Render(1)
Render(1.5)
Simulate(3)
Render(2)
Render(2.5)




Networking model: UDP
Since UDP is the fastest and input is send from the past frames it is the best.

Reasons to not use TCP: Slow and it might not send small packets, it also queue packets even if it is better to receive packets more advanced in game time.


Networking setups: P2P




Architecture
- World: Manages layers, has sub worlds that manages the systems (like a physics world)
- Layer: Stores components




No server
Every clint is also their own server
Since only input is transfered the authority is on the client themselves
-> no host migration
-> no host hacking
-> no host advantage (because of 0 latency)







Prevent cheating
A hash is generated from the complete packet (input and frame) and game state. It is a 128 bit number. 
Note: UDP can also corrupt data, so an invalid hash might be possible without cheating



Questions


- Does rollback actually solve non-authorative cheating attempts, since only the input is transfered?

- Does rollback networking work better for p2p or server-client architecture?

- How do you deal with a very bad internet connections that its above or at the limit of the max rollback frames?

- Most game that use rollback are fighting games, but from the outside, it doensnt seem to be that expensive to calculate a rollback-step. With only a few colliders and maybe a couple of hundres bytes of gamestate how do they still run into performamnce issues (like Mortal Kombat only supports 7 frames of rollback)?




Ressources:
https://www.youtube.com/watch?v=0NLe4IpdS1w
https://www.youtube.com/watch?v=7jb0FOcImdg
https://www.reddit.com/r/gamedev/comments/4eigzo/generally_how_often_do_most_realtime_multiplayer/
https://www.freecodecamp.org/news/tcp-vs-udp/
https://gafferongames.com/post/udp_vs_tcp/





No server architecture

Default gameplay with good internet connection for everyone

- The client sends the input package with hash to the other clinet every networking frame. When it receives the package from other client it rolls back and applies the input. When gathering the input it creates the hash from the input and the previous hash. The first hash of the game will be the game specific hash.

When receiving input it can instantly verify the input by updating the latest saved hash from that client until it has reached the frame of the new input. When they dont match the client knows that is has received faulty input. In this case it



Server architecture

- Server saves the connection speed between a server and client
- The server does not save the game data, when a new client joins or a desync occurs, the server requests the game data from one of the clients and send it to the client
- 



2Rollback & Prediction


Only send input, the frame and a hash incooperating the input, frame and game state
When receiving the packet, the hash is evaluated to check if it matches the data.


int NetworkingFPS = 15 FPS (66.6ms) (~4 rendering frames)
rate of sending packets

int PhysicsFPS = 30 FPS (33.33ms)
the physics in the game are simulated every 

int RenderingFPS = variable
the rendering can be done at any frame rate, and interpolates between the physics frames. Allows sync. The physics are prioritized, so when the hardware cant keep up with the Physics, the Rendering FPS is decreased.
The rendering runs on a different thread

int RollbackFramesCount = 15 (500ms)

Related to the PhysicsFPS. 


Save the latest game states for the last (RollbackFramesCount) frames.


Simulation Thread:
1) Get Input
2) Generate Hash from input and previous game state
3) Generate packet with the frame (number, from last game state), input and hash
4) If (networking frame), send the packet to other clients, including recent packets
5) Check and get the received packets
6) Calculate next physics step using the most recent packet frame every client. Rollback to the frame with the  


Every game state / frame keeps track of which clients it knows the input from and which client is predicted. When no client needed to be predicted this Game state is sealed and is the minimum next rollback target




When connecting to a game that is already active the new player first requests the gamedata to download. In the meantime the other players are already sending input to he new player even if he is still downloading. When the download is somplete he will first use the received input to catch up as fast as possible to the current game state.

When sending the input you also send the input of the last
RollbackFramesCount.


Issues
Lag spike: 
Player 1 - 2: 30ms
Player 2 - 3: 50ms
Player 3 - 1: 3s

Player 3 and 1 both realize there is a bad connection between them and send to each other to snap back to original position
So maybe a server is needed on one clients, who deals 

Idea:
Priority list of the clients: based on the connection speed (better connection: higher priority)
with higher priority the player will

Every client has their own priority list of other clients. In case 
Is also has a priority list of itselfs on other clients

So there is a 2s delay between two clients, they both are at the bottom priority list and 

Priority list needs to be same for every client

so when there is a lag spike every client who detects it compares the priority and if it is bigger then the other client, it sends out the complete game state back. The client now might now expects from every higher client with slow connection a game data package. so from some clients it receives the input, which are immediatly applied and from other ot first does not receive anything for 2s. In this case if the last unknown frame > max rollback frames, the player will apply this time the previous inputs of itself to the screen. The other clients that have detected the slow 

Every time a package is send the client also send the connection speeds that it has with the other clients (in frames) (1 byte), so all clients know when they dont receive packages if they, or the other client is the reason for this

Send: 
- the last perfect frame the frame that it knwos it correct with all input received)
- the last frame where it received the input of every client

sum up the framesof every connection that a clinet has and compare the value with its own average connection. Since it took time add the connection speed in frames it has with the other client

this comparison might still be off

so if it doesnt receive the needed input in time at th moment it needs to know the input in order to progress decide at this moment in time if it stops otself or if it stops the other

perfect (most likely): one stopped itself, the other stopped the other
bad (not likely): both stopped themselves. They both re

2 frames rollback (66ms) : no penalty (only input predicttion)
3 - 7 frames rollback (100ms - 233ms) : delay package to other client
8 - 60 frames rollback (266ms - 2000ms) : if client is the reason: only do rollback when all input is known, while waiting for input: keep previous input and  input when client is the cause and then just stop rendering until client received all input and can . only calculate 


Constant input prediction


Solution; Allow for more rollback time, (lik up to 2s, but stil make a limit of where it should stop waiting for input and progress without the other clinet that has bad connection





Optimizing
Combining with partition trees - when calculating a completely new frame, also save the collision response data and send it to the previous game state. When resimulating a frame, it checks which objects have been directly affected by the new input. Then get the cells where these objects are located and just apply the veloicity and angular velocity without additional calculations.
Interpolation
A rendering world - gets the necesarry components from the world manager

It needs: the current layer 



for animation:
it recalculates the animation time step every step.


Simulate(2)
Render(1)
Render(1.5)
Simulate(3)
Render(2)
Render(2.5)




Networking model: UDP
Since UDP is the fastest and input is send from the past frames it is the best.

Reasons to not use TCP: Slow and it might not send small packets, it also queue packets even if it is better to receive packets more advanced in game time.


Networking setups: P2P




Architecture
- World: Manages layers, has sub worlds that manages the systems (like a physics world)
- Layer: Stores components

-> The input also saves the amount of frames this was pressed to reduce data amount (not saving when input was pressed for the same multiple frames)


No server
Every clint is also their own server
Since only input is transfered the authority is on the client themselves
-> no host migration
-> no host hacking
-> no host advantage (because of 0 latency)




Methods of cheating
- Spoofing input packets                                    (Severe)
- Read game data for additional info (player location)      (Minimal, the entire game state is known, but has not that much valuable information for the player that is not already shown)
- Colliders display                                         (Low, colliders should match roughly the displayed shapes anyway - many fights are not done in close range where that matters that much)
- Modifying game data (Health, CD)                          (Low, checksum will findout if any game data has been modified, only issue is when determining correct game state)
- Aim bots                                                  (Low, Aim is no crucial part, and only minimal in skill expression - with salow projectiles and fast moving players no perfect aim exists anyway)
- Modifying game tick speed                                 (Low, the tixck rate is fixed, if the trick rate is modified, it will send future packets with input of old data, resulting in bad play, results in a lot of rollbacks)
- Auto clicker                                              (Low, no action is dependent on spamming abilities)
- Simulate lag                                              (Severe, witholding input data to minimize reaction time for other clients)
- Abuse of prediction functionality                         (Maximal, can give a powerful overlay with trajectories, same as the golden player state)
- Target other clients                                      (Severe, in lobbies multiple clients sending faulty data to 1 target client which will be wrongly accused)
- Modifying assets (louder sounds, brighter textures)       (Low, will decrease player enjoyment more then it helps)
- Macros / replay inputs                                    (Minimal, can be usefull in certain cases, but since reactive play is often neede not that important. Might also get implemented as a feature if needed)
- Force other clients to rollback                           (Minimal, game should be able to run on max rollbacks anyway)
- Send faulty win                                           (Severe, No authorative instance to determine correct result)
- Frame perfect blocking                                    (Low, blocking is no core game mechanic)

-> Most cheating attempts only slightly increase the players stength, resulting in diminishing returns
-> Some critical cheating methods related to modifying packets



Prevent cheating



A hash is generated from the complete packet (input and frame) and game state. It is a 128 bit number. 
Note: UDP can also corrupt data, so an invalid hash might be possible without cheating
-> Use bitflip prevention like in qr codes


Every player has a hash stored for every other player it is connected to
This hash is used more hashes for input

A)
send input from player a to b:
- generate hash from input and player B hash, which advances the player B hash to its next state
- send the input and hash to player B
- pl
- player B encrypts the data and check 
1) if the hash matches the input data
2) if the hash matches its own player hash with the correct number from seed
- 


B)
- player A sends the input and a basic hash do verification on a basic level
- player B receives the input and declares and uses it, but not yet verifies it.
- player B 

method to modify the 


- if a player just sends wrong input, on all other players screen that person just inputs garbage. Here there is no need to veridy input, since the cheater now himseelf is affected most as their connection to all other players is desynced
- Every frame every player creates a hash of the current game state and sends it to the other clients. The clients send the game state hash of other clients to each other
- Normally: A client can detect a desync by checking if (of a completed frame) all state hashes are the same. 

(Considering a game with 5 persons)
- If a SINGLE client has a different hash: that client is desynced, send current game state to it
- If two clients have 
- If all clients have different hashes: Cheating used




Delay input
- Every client tracks the time is takes for a packet to arrive. This is (active frame at that time - last received packet frame). If that value exceeds a limit (like 10 frames) the information is delayed
- Current delay is compared with default delay to that client to mitigate natural occuring lags (but is saved as potential delay attempt)
- Issue: Doubled connection time for already slow connections




Send faulty win
- When no competitive environment: Show what the client believes to be true, if a cheater gets a win screen after losing that is fine as the winning client still gets the correct screen
- Give the option to player to blacklist certain players they believe to be cheating

- with server: all clients send win state to server. If they dont match, the server requests the entire game input of all clients, and replays the game, giving it 
- Issues: the server will need to determine which input to choose
- Server will take the input that each client provided. Maybe still not possible to completely verify game
- input is routed over the server anyway


-> Proveide two two modes: Ranked & Casual

Ranked: Input is transferred over server giving a competetive environment
Casual: Checks if any server / server capacity is available - uses server if possible. Will use p2p when not


Serverless Ranked
- Every client stores their rank in a hidden steam leaderboard
- use obfuscating to hide this process (like act like saving config files

- stores a hash containing the rank
- if the client that verifies the other clients rank and discovers a faulty hash, it will display a cheater rank, the cheater (and friends) themselves will not see this




Determine culprit in case of desync

- 

- send the input to others by sending them over other clients, that are unable to modify these packets as they are encryopteds with keys only the two other clients know



Every client shares a key with every other client (5 clients, 5 different keys)
The input is hashed with the key 5 time and all 5 are send to all clients
When receiving an input packet (consisting out of a list of inputs from the past frames and all other hashes from the clients), this is stored in a list and compared. The hashes and game state hashes can be compared by every client to determine the cheater

- A client expects 


in case of some clients having wrong states

- 1 of 5 wrong: correct 1 client and give a warning (saved on the other clients devices)
- 



Workflow (considering 5 clients)
- Every client has a private and a public key
- Every frame the client generates 5 input hashes with the input of current frame and the public key of the other clients. 

a packet is send to every other client containig with some data
 - the input of the current frame hashed with 


- when a client receives a game state 


Questions


- Does rollback actually solve non-authorative cheating attempts, since only the input is transfered?

- Does rollback networking work better for p2p or server-client architecture?

- How do you deal with a very bad internet connections that its above or at the limit of the max rollback frames?

- Most game that use rollback are fighting games, but from the outside, it doensnt seem to be that expensive to calculate a rollback-step. With only a few colliders and maybe a couple of hundres bytes of gamestate how do they still run into performamnce issues (like Mortal Kombat only supports 7 frames of rollback)?




Ressources:
https://www.youtube.com/watch?v=0NLe4IpdS1w
https://www.youtube.com/watch?v=7jb0FOcImdg
https://www.reddit.com/r/gamedev/comments/4eigzo/generally_how_often_do_most_realtime_multiplayer/
https://www.freecodecamp.org/news/tcp-vs-udp/
https://gafferongames.com/post/udp_vs_tcp/





No server architecture

Default gameplay with good internet connection for everyone

- The client sends the input package with hash to the other clinet every networking frame. When it receives the package from other client it rolls back and applies the input. When gathering the input it creates the hash from the input and the previous hash. The first hash of the game will be the game specific hash.

When receiving input it can instantly verify the input by updating the latest saved hash from that client until it has reached the frame of the new input. When they dont match the client knows that is has received faulty input. In this case it



Server architecture

- Server saves the connection speed between a server and client
- The server does not save the game data, when a new client joins or a desync occurs, the server requests the game data from one of the clients and send it to the client
- 














Questions Answered by David Dehaene (the author of "Delta Rollback: New optimizations for Rollback Netcode" and Game dev behin the rollback netcode of Jewel Run)


- What can you do when a client cant keep up with the simulation? Is pausing the only option?
I have not tested this, but I think there could be a way to slow the simulation down as well? Depending on the game it can be more acceptable than pausing.
You can also discard the inputs from the player that is lagging behind, though this is more easily done with a server relaying player inputs. I don't think it has ever been done in p2p, but I believe it can be done

- What is a good update time for games using rollback networking (physics FPS / Networking FPS)
Not sure in absolutes but you can slow your physics FPS down to have a huge impact on rollback performance, as less frames will get you the same latency. For Jewel Run we were able to decrease the physics FPS to 15 and I would challenge players to notice

- Does rollback actually solve non-authorative cheating attempts, since only the input is transferred?
Yes some kind of cheats are impossible with rollback, but it also opens the door to new crafty ways of cheating ^^. As all players have all the information in the game it's also very difficult to prevent cheats such as wall hacks

- Why do many games struggle with rollbacks even though they their game state and physics simulation is relatively simple (like fighting games)
I'm not so sure why a fighting game would have many issues with this, but I don't have the experience here. Maybe because networking is taken into account late(r) in development?






Causes for issues
- A player has a very bad internet connection to the other players
- A player has a very bad internet connection to one player, but a good one to the other players











Doing rollbacks + input with better performance
- Pruning + Saving data for future calculations
- Spatial map for object groups. Calculate collisions per group. On rollback only recalculate group if an object inside has changed (or has moved in). Save delta changes per group. Store collision response results per object in a group, and the entities each object collided with. Every entity stores per group 1 byte that indicates if it is also present in other groups (and the direction of the othert groups (max 3)). Every object is smaller than the group size. 
- Every group is sorting the entities for sweep and prune.
- Delta rollback: Saving only changes in game state. 2 saved complete game states: last confirmed game state and most recent game state, that we are constantly changing (can also add 1 in the middle).
- Run physics calculations on low FPS. Separate rendering with interpolation
- Support up to 1 second of rollback time
- Add 1 frame of lockstep since that is either way delayed because of interpolation)




Optimizing collision detection 
https://leanrada.com/notes/sweep-and-prune-2/








Define a player with its action, only modifyable by the controlling client. A player can influence a global object with no defined host. This object is part of the rollback group


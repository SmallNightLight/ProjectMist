Rollback & Prediction


Only send input, the frame and a hash incooperating the input, frame and game state
When receiving the packet, the hash is evaluated to check if it matches the data.


int NetworkingFPS = 15 FPS (66.6ms) (~4 rendering frames)
rate of sending packets

int PhysicsFPS = 30 FPS (33.33ms)
the physics in the game are simulated every 

int RenderingFPS = variable
the rendering can be done at any frame rate, and interpolates between the physics frames. Allows sync. The physics are prioritized, so when the hardware cant keep up with the Physics, the Rendering FPS is decreased.
The rendering runs on a different thread

int RollbackFramesCount = 15 (500ms)

Related to the PhysicsFPS. 


Save the latest game states for the last (RollbackFramesCount) frames.


Simulation Thread:
1) Get Input
2) Generate Hash from input and previous game state
3) Generate packet with the frame (number, from last game state), input and hash
4) If (networking frame), send the packet to other clients, including recent packets
5) Check and get the received packets
6) Calculate next physics step using the most recent packet frame every client. Rollback to the frame with the  


Every game state / frame keeps track of which clients it knows the input from and which client is predicted. When no client needed to be predicted this Game state is sealed and is the minimum next rollback target




When connecting to a game that is already active the new player first requests the gamedata to download. In the meantime the other players are already sending input to he new player even if he is still downloading. When the download is somplete he will first use the received input to catch up as fast as possible to the current game state.

When sending the input you also send the input of the last
RollbackFramesCount.


Optimizing
Combining with partition trees - when calculating a completely new frame, also save the collision response data and send it to the previous game state. When resimulating a frame, it checks which objects have been directly affected by the new input. Then get the cells where these objects are located and just apply the veloicity and angular velocity without additional calculations.
Interpolation
A rendering world - gets the necesarry components from the world manager

It needs: the current layer 



for animation:
it recalculates the animation time step every step.


Simulate(2)
Render(1)
Render(1.5)
Simulate(3)
Render(2)
Render(2.5)




Networking model: UDP
Since UDP is the fastest and input is send from the past frames it is the best.

Reasons to not use TCP: Slow and it might not send small packets, it also queue packets even if it is better to receive packets more advanced in game time.


Networking setups: P2P




Architecture
- World: Manages layers, has sub worlds that manages the systems (like a physics world)
- Layer: Stores components




No server
Every clint is also their own server
Since only input is transfered the authority is on the client themselves
-> no host migration
-> no host hacking
-> no host advantage (because of 0 latency)







Prevent cheating
A hash is generated from the complete packet (input and frame) and game state. It is a 128 bit number. 
Note: UDP can also corrupt data, so an invalid hash might be possible without cheating



Questions


- Does rollback actually solve non-authorative cheating attempts, since only the input is transfered?

- Does rollback networking work better for p2p or server-client architecture?

- How do you deal with a very bad internet connections that its above or at the limit of the max rollback frames?

- Most game that use rollback are fighting games, but from the outside, it doensnt seem to be that expensive to calculate a rollback-step. With only a few colliders and maybe a couple of hundres bytes of gamestate how do they still run into performamnce issues (like Mortal Kombat only supports 7 frames of rollback)?




Ressources:
https://www.youtube.com/watch?v=0NLe4IpdS1w
https://www.youtube.com/watch?v=7jb0FOcImdg
https://www.reddit.com/r/gamedev/comments/4eigzo/generally_how_often_do_most_realtime_multiplayer/
https://www.freecodecamp.org/news/tcp-vs-udp/
https://gafferongames.com/post/udp_vs_tcp/





No server architecture

Default gameplay with good internet connection for everyone

- The client sends the input package with hash to the other clinet every networking frame. When it receives the package from other client it rolls back and applies the input. When gathering the input it creates the hash from the input and the previous hash. The first hash of the game will be the game specific hash.

When receiving input it can instantly verify the input by updating the latest saved hash from that client until it has reached the frame of the new input. When they dont match the client knows that is has received faulty input. In this case it 


